{"version":3,"sources":["index.js","verifySigUtil.js","uitls.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var __TEMP__ = require('./verifySigUtil');var signConfig = __TEMP__['signConfig'];var signProvider = __TEMP__['signProvider'];var verifySigUtil = __TEMP__['verifySigUtil'];\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var signUtil = exports.signUtil = {\n    setProvider(provider) {\n        Object.assign(signProvider, provider);\n    },\n    setConfig(config) {\n        Object.assign(signConfig, config);\n    },\n    getServerKey() {\n        return verifySigUtil.getServerKey();\n    },\n    getRequestBody(data, option) {\n        return verifySigUtil.getSignData(data, option);\n    }\n};\n","var __TEMP__ = require('./uitls');var base64Decode = __TEMP__['base64Decode'];var encryptAES = __TEMP__['encryptAES'];var getStringValue = __TEMP__['getStringValue'];var p2Arry = __TEMP__['p2Arry'];\nconst VERIFY_SIG_KEY = 'VERIFY_SIG_KEY';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var signProvider = exports.signProvider = {};\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var signConfig = exports.signConfig = {\n    djEncrypt: 1,\n    sv: 0,\n    signNeedBody: 0,\n    isGray: 0\n};\n/**\n *接口验签排序\n */\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function genSignData(data, option) {\n    // console.log('原始数据-----', data);\n    const copyData = Object.assign({}, data);\n    // console.log('拷贝数据-----', copyData);\n    // const signNeedBody = copyData.signNeedBody;\n    // functionId 和 signNeedBody 不参与验签\n    delete copyData.functionId;\n    delete copyData.signNeedBody; // 避免外面传入了\n    let unordered = {};\n    // signNeedBody ==1 ,body参与验签排序，否则按照线上规则处理\n    if (option.signNeedBody) {\n        try {\n            let body = copyData.body;\n            delete copyData.body;\n            body = getStringValue(JSON.parse(body));\n            body = body.substring(0, body.lastIndexOf('&'));\n            unordered = Object.assign({}, copyData, { body: body });\n        }\n        catch (e) {\n            unordered = copyData;\n        }\n    }\n    else {\n        unordered = copyData;\n    }\n    const ordered = {};\n    // 按照接口入参的key进行排序\n    Object.keys(unordered).sort().forEach(function (key) {\n        if (key != 'functionId') {\n            ordered[key] = unordered[key];\n        }\n    });\n    // 取出value不等于空字符串的值\n    const values = Object.values(ordered).filter(ele => {\n        if (ele != '') {\n            return ele;\n        }\n    });\n    // console.log(values.join('&'));\n    // SHA256加密\n    const HmacSHA256 = require('crypto-js/hmac-sha256');\n    const encHex = require('crypto-js/enc-hex');\n    // const md5 = require('crypto-js/md5');\n    const origin = values.join('&');\n    // console.log(\"原始拼接串：\", origin);\n    // const md5Origin = option.version === 2 ? md5(origin).toString() : origin;\n    // const signKey = option.version === 2 ? option.dynamicKey : signConfig.ks.v1;\n    // console.log(\"md5 拼接串：\", md5Origin);\n    // console.log(\"确认一下key：\", option.signKey);\n    const hash = HmacSHA256(origin, option.signKey);\n    const hashInHex = encHex.stringify(hash);\n    // console.log(\"hashmac之后：\", hashInHex)\n    // console.log(\"=========================\")\n    return hashInHex;\n};exports.genSignData = genSignData\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var verifySigUtil = exports.verifySigUtil = {\n    /**\n         * 是否走降级\n         */\n    degrade: false,\n    /**\n       * 正在获取key\n       */\n    getKeying: false,\n    error: false,\n    setItem(key) {\n        var _a, _b;\n        return (_b = (_a = signProvider.storage) === null || _a === void 0 ? void 0 : _a.setItem(VERIFY_SIG_KEY, key)) === null || _b === void 0 ? void 0 : _b.catch(() => { });\n    },\n    async getItem() {\n        var _a;\n        const itemStr = await ((_a = signProvider.storage) === null || _a === void 0 ? void 0 : _a.getItem(VERIFY_SIG_KEY));\n        let item = itemStr;\n        try {\n            if (itemStr) {\n                item = JSON.parse(itemStr);\n            }\n        }\n        catch (error) {\n            // console.log('getItemError')\n        }\n        return item;\n    },\n    /**\n         * 获取用来加密报文的key\n         */\n    async getServerKey() {\n        var _a, _b, _c;\n        try {\n            if (this.error || this.getKeying) {\n                return { ing: this.getKeying };\n            }\n            this.getKeying = true;\n            const url = `https://${(signProvider.domainKey === 'daojia' || signProvider.domainKey === '') ? '' : 'pre-'}ds.jddj.com/getds`;\n            // const [error, resp] = await api_getImgGif().toArray();\n            const [error, resp] = await p2Arry((_a = signProvider.api) === null || _a === void 0 ? void 0 : _a.call(signProvider, { type: 'GET', url, djEncrypt: 1 }));\n            setTimeout(() => {\n                this.getKeying = false;\n            }, 0);\n            if (error || resp.code != '0') {\n                // 失败后，本次请求不再走新验签\n                this.error = true;\n                this.degrade = true;\n                // // 本次直接降级老验签\n                return { degrade: true };\n            }\n            this.degrade = false;\n            const key = (_b = resp.result) === null || _b === void 0 ? void 0 : _b.k;\n            const v = (_c = resp.result) === null || _c === void 0 ? void 0 : _c.v;\n            // 获取成功了持久化到本地\n            await this.setItem(JSON.stringify({ key, v }));\n            return { key };\n        }\n        catch (error) {\n            this.error = true;\n            this.degrade = true;\n            return { error };\n        }\n    },\n    async getSignData(data, { sv: busiSv } = {}) {\n        var _a;\n        busiSv = (busiSv === undefined || busiSv === null) ? 1 : busiSv;\n        const item = await this.getItem() || {};\n        const sv = signConfig.sv; // 配置系统的开关\n        const signNeedBody = signConfig.signNeedBody;\n        const v = item.v || '';\n        const oBak = { signNeedBody, functionId: data.functionId };\n        //  加个兜底 ———— try catch 如果2级错误了，走1级兜底\n        try {\n            if (item.key && !this.degrade && sv == 1 && busiSv == 1 && !!signConfig.isGray) {\n                const signKey = base64Decode(item.key);\n                // console.log(\"=========================\")\n                // console.log(\"原始key:\", item.key);\n                // console.log(\"base64Decode Key:\", signKey)\n                if (data.v2) {\n                    // 新增二级验签字段signV2，存放客户端指纹信息（设备基础信息+是否调试模式），AES加密后，提供服务端拦截识别\n                    data.v2 = encryptAES(JSON.stringify(data.v2));\n                }\n                return {\n                    sv: 1,\n                    requestBody: Object.assign(data, {\n                        signKeyV1: genSignData(data, { version: 2, signNeedBody, signKey }) + v\n                    }, oBak)\n                };\n            }\n        }\n        catch (error) {\n        }\n        if (signConfig.isGray == 1 && sv == 1 && !!data.deviceId) { // 如果灰度命中且sv配置系统是开启状态，降级才更新key\n            this.getServerKey();\n        }\n        return {\n            sv: 0,\n            requestBody: Object.assign(data, {\n                signNeedBody,\n                signKeyV1: genSignData(data, { version: 1, signNeedBody, signKey: (_a = signProvider.ks) === null || _a === void 0 ? void 0 : _a.v1 })\n            }, oBak)\n        };\n    }\n};\n","var __TEMP__ = require('crypto-js/core');var CryptoJSCore = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('crypto-js/aes');var AES = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('crypto-js/pad-pkcs7');var Pkcs7 = __REQUIRE_DEFAULT__(__TEMP__);\n/**\n * 处理好promise，返回数组[error,value]\n * 当error是null时，表示promise返回正常\n * @param {Promise}} promise\n */\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function p2Arry(promise) {\n    if (!promise) {\n        return [{ msg: 'Not a Promise!' }];\n    }\n    return promise.then(data => {\n        return [null, data];\n    }).catch(err => [err]);\n};exports.p2Arry = p2Arry\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function getStringValue(data) {\n    let stringValue = '';\n    // 排序\n    const oredered = {};\n    Object.keys(data).sort().forEach(function (key) {\n        oredered[key] = data[key];\n    });\n    // 遍历\n    for (const i in oredered) {\n        const value = oredered[i];\n        if (Object.prototype.toString.call(value) === '[object Object]') {\n            stringValue += (getStringValue(Object.prototype.toString.call(value) === '[object Object]' ? value : JSON.parse(value)));\n        }\n        else if (Object.prototype.toString.call(value) === '[object Array]') {\n            value.map((item) => {\n                if (Object.prototype.toString.call(item) === '[object Object]') {\n                    stringValue += (getStringValue(Object.prototype.toString.call(item) === '[object Object]' ? item : JSON.parse(item)));\n                }\n                else {\n                    if (!(item === '' || item === null || item === undefined)) {\n                        stringValue += item + '&';\n                    }\n                }\n            });\n        }\n        else {\n            if (!(value === '' || value === null || value === undefined)) {\n                stringValue += value + '&';\n            }\n        }\n    }\n    return stringValue;\n};exports.getStringValue = getStringValue\nconst S_KEY = 'J@NcRfUjXn2r5u8x';\nconst S_PARAMETER = 't7w!z%C*F-JaNdRg';\n/**\n * api 加密\n */\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function encryptAES(data) {\n    const CBCOptions = {\n        iv: CryptoJSCore.enc.Utf8.parse(S_PARAMETER),\n        mode: CryptoJSCore.mode.CBC,\n        padding: Pkcs7\n    };\n    const key = CryptoJSCore.enc.Utf8.parse(S_KEY);\n    const secretData = CryptoJSCore.enc.Utf8.parse(data);\n    const encrypted = AES.encrypt(secretData, key, CBCOptions);\n    return encrypted.toString();\n};exports.encryptAES = encryptAES\n/**\n* api 解密\n*/\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function decryptAES(data) {\n    const CBCOptions = {\n        iv: CryptoJSCore.enc.Utf8.parse(S_PARAMETER),\n        mode: CryptoJSCore.mode.CBC,\n        padding: Pkcs7\n    };\n    const key = CryptoJSCore.enc.Utf8.parse(S_KEY);\n    const decrypt = AES.decrypt(data, key, CBCOptions);\n    return CryptoJSCore.enc.Utf8.stringify(decrypt).toString();\n};exports.decryptAES = decryptAES\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function base64Decode(key) {\n    const decode = CryptoJSCore.enc.Base64.parse(key);\n    return CryptoJSCore.enc.Utf8.stringify(decode);\n};exports.base64Decode = base64Decode\n"]}